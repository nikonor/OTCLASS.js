otclass.js и otclass2.js
===

##Внимание##
В текущей версии произошли серьезные изменения. Прочитайте часть про **Обработка результата работы методов** и имеет ввиду, что данная версия обратно не совместима из-за смены типа возврата функции sync

# Введение #


В данной версии рассматривается otclass2.js. Главное отличие второй версии в том, что она работает асинхронно с сервером. Т.е. схема работы теперь следующая:

* объект получаем команду на какое-либо действие.
* это изменение происходит в данных в броузере
* картинка обновляется
* на сервер отправляется команда на изменение
* специальный объект записывается в словарь объектов, отправленных на сервер
* если на сервере все прошло нормально, то объект из словаря просто удаляется
* если на сервере произошла ошибка, то произойдет откат этого изменения


## Идея ##

Основная идея этого модуля - разделить данные, их представление и немного упростить работу со всем этим. Для того, чтобы это как-то взлетело, да еще и было кроссброузерно, я решил опираться на следующие правила:

* программист лучше модуля знает, как устроены его данные
* мы работаем только с массивом словарей 
    <code>
        var data = [{'id':1,'name':'foo'},{'id':2,'name':'bar'}];
    </code>
    
* существует четыре основных действия с данными (учитывая наши ограничения):
    * добавление записи (словаря) в массив
    * удаление записи из массива
    * изменение записи в массиве


## Необходимые библиотеки ##
* [http://jquery.org/]() - тут даже не обсуждается :-)
* [otmes.js](https://github.com/nikonor/otmes.js) - нужна для вывода сообщений (в otclass2.js такого требования нет)
* [Handlebars.js](http://handlebarsjs.com/) - шаблонизатор
* [jQuery.tmpl] (https://github.com/jquery/jquery-tmpl) - или такой шаблонизатор

# Как это работает? #

В общем случае вся работа сводится к созданию объекта и дальнейшим изменением данных в нем. Если все изменения делаются через стандартные вызовы, то модуль автоматически изменит представление данных, конечно, после работы с хранилищем данных.

Рассмотрим подробнее.

## Конструктор ##

Вот так выглядит создание объекта

    var ot = new OTCLASS(
        {'id':'sp_crits',
        'data':data,
        'div_id':'div1',
        'tmpl_id':'nb_tmpl',
        'sort':['field1', '-field2'],
        'stringify': 1,
	      'debug':1,//otclass.js,
	      'notsync': 1, // otclass2.js  
        'page_limit':10,
        'script_name':'/script.pl',
        FUNCNAME:funcname,
        onError':function(error_text){...}
        });

* **id** - уникальный идентификатор объекта, он передается в базу при синхронизации, для того, чтобы можно было понять, действие с какими объектами надо делать на той стороне.
* **data** - это данные, которые будут переданы в шаблон
* **div_id** - id объекта (div, p, span), в котором будет лежать перерисованный объект или какой-либо селектор jQuery
* **tmpl_id** - id темплейта
* **sort** - необязательное поле, если оно указано, то после каждого изменения данных будет вызываться сортировка данных по полям, которые были переданы в данном параметре. Если перед именем поля поставить минус, то сортировка будет выполнена в обратном порядке.
* **stringify** – необязательный параметр. Если передать единицу, то данные будут обёрнуты в JSON.stringify() перед отправкой на сервер.
* **page_limit** - кол-во записей на станице. Если указан этот параметр, то будет работать навигация. Только важно помнить, что ссылки для навигации вам придется делать самими. Для этого можно использовать паременные  **this.leftnav** и **this.rightnav**.
* **debug** (otclass.js only) - параметр дающий возможность работать без сервера. Может принимать 3 возможных значения
	* 1 - сервер "возвращает" сообщения, что все прошло нормально
	* 2 - сервер "возвращает" сообщения об ошибке
	* все остальное, в том числе отсутствие параметра - работаем с сервером
*  **onError** - функция, что срабатывает, если пришел откат.
* **FUNCNAME** - это параметр для переопределения функций. См. раздел **Замещение**

*Обращаю внимание на то, что нигде не описывается формат данных, которые передаются в конструктор. Это сделано для того, чтобы добиться максимальной гибкости. Именно это и означает первое правило*


## Основные вызовы ##

### Добавление ###

    ot.add({'id':5,'name':'пять'});
    ot.add([
            {'id':6,'name':'шесть'},
            {'id':7,'name':'семь'}
            ]);

тут все просто. Мы вызываем функцию добавления, передавая в нее либо словарь, либо массив словарей. 


### Удаление ###

    ot.remove({'field':{'type':'==','val':5}});
    ot.remove({'field':[{'type':>','val':10}},{'type':'<','val':20}]);   
    ot.remove({'field':{'type':'isnull'}})     
    
опять же простой вызов. мы указываем какое поле проверяем и чему оно должно быть равно, чтобы строка была удалена. 

Здесь имеет смысл описать то, как мы строим условия. Они одинаковые везде. И в удалении, и в обновлении, и в накладывании фильтров. Итак, на данный момент существуют следующие типы.

* ==  
* eq
* \>
* \>=
* <
* <=
* like
* between 
* isnull



    
### Обновление ###

    ot.update({'id':[{'type':'==','val':4}]},{'name':'Новое имя','age':100})
    
Тут все почти аналогично предыдущему примеру. Условие и новое значение словаря


### Применение фильтров ###

    ot.filter({'age':[{'type':'>','val':21}]})
    
Если отдать такую команду, то будь показаны все записи, где поле age имеет значение больше 21. 


### Отправка данных на сервер ###

Вся работа с сервером происходит из функции **sync**. Внутри это функции есть вызов стандартной функции $.ajax . 

### получение данных ###

Чтобы получить данные из набора можно вызвать функцию **get**. 
  
    var a = ot.get([{'field':'id','eq':5}]);

В данном случае на параметр функции распространяются все правила условия. Т.е. оно может быть просто словарем, если оно одно, или массивом, если их несколько. 

Функция вернет false, если ничего не найдет или массив строк

### Обработка результата работы методов ###

Методы add, remove и update возвращают deferred-объект. Соответственно, можно делать так:

    ot.update({'id':[{'type':'==','val':4}]},{'name':'Новое имя','age':100}).done(function(){alert('Успешно обновлено')}).fail(function(){alert('Не удалось обновить')}).always(function(){alert('Получилось или нет, посылаю вам привет')})

## На стороне сервера ##

Сервер получает данные в формате JSON и должен вернуть в JS объект, состоящий из пар ключ-значение. Обязательно должны быть следующие ключи: 

* status: Ok или Error
* dts: то же самое, что передавали в $.ajax
* new_row: новое значение 
* error_text: текст сообщения об ошибке

Все остальные ключи - могу быть, а могу не быть. 


В случае работы через CGI, все довольно легко ложится в объект типа хэш/словарь. Даже если там есть массивы, а они есть всегда. 

Вот пример вывода объекта, полученного сервером (perl,понятно). 

** UPDATE **

    $VAR1 = {
              'new_rows' => {
                              'next_weight' => '30',
                              'comment3' => 'comment3 text',
                              'name' => 'Name text',
                              'comment4' => 'comment4 text',
                              'weight' => '20',
                              'id' => '2',
                              'comment1' => 'comment1 text',
                              'comment2' => 'comment2 text'
                            },
              'obj' => 'sp_crits',
              'turn' => 'update',
              'uslovie' => {
                             'eq' => '2',
                             'field' => 'id'
                           },
              'dts' => '1344240097',
              'do_what' => 'admindb'
            };

** ADD **

    $VAR1 = {
              'new_rows' => [
                              {
                                'type_id' => '1',
                                'comment3' => 'НОВОЕ ОПИСАНИЕ ОЦЕНИКИ 3',
                                'weight' => '25',
                                'comment4' => 'НОВОЕ ОПИСАНИЕ ОЦЕНИКИ 4',
                                'name' => 'НОВЫЙ КРИТЕРИЙ',
                                'comment1' => 'НОВОЕ ОПИСАНИЕ ОЦЕНИКИ 1',
                                'comment2' => 'НОВОЕ ОПИСАНИЕ ОЦЕНИКИ 2'
                              }
                            ],
              'obj' => 'sp_crits',
              'turn' => 'add',
              'test_hash' => {
                               'eq' => '2',
                               'field' => 'id'
                             },
              'dts' => '1344240668',
              'do_what' => 'admindb'
            };

** REMOVE **

    $VAR1 = {
              'obj' => 'sp_crits',
              'turn' => 'remove',
              'uslovie' => {
                             'eq' => '55',
                             'field' => 'id'
                           },
              'dts' => '1344240771',
              'do_what' => 'admindb'
            };
Вот как этот объект получается. 

    foreach my $p ($q->param()){
        if ($p =~ /\[.+?\]/ ){
            my @pp = map {$_ =~ s/\]//; $_ } split('\\[',$p);
            eval(__make_hash_str("ret",@pp,$uref->fromUTF8("koi8-r", $q->param($p))));
        }else{
            $ret->{$p} = $uref->fromUTF8("koi8-r", $q->param($p));
        }
    }
    
    sub __make_hash_str{
	    my ($name,@par) = @_;
	    my $val = pop(@par);
	
	    my $r = "\$".$name."->";
	
	    foreach my $i (@par){
	        if ($i =~ /^\d+$/){
	            $r .= "\[$i\]";
	        }else{
	            $r .= "\{\'$i\'\}";
	        }
	    }
	    $r.= "='$val';";
	
	    return $r;
    }


Теперь рассмотрим, что же мы имеем. 

* obj - тот самый id из конструтора. Для простоты можно использовать имя таблицы или намек на нее
* turn - какую операцию нужно сделать. Тут может быть **только**: add, remove, update
* uslovie - бывает только при turn равном remove или update
* new_rows - словарь или массив словарей c данными, которые надо обрабатывать

Что со всем этим делать дельше - решать вам:-)

Теперь про про один тонкий момент. При добавлении, как мы все понимаем, появляется новая сущность, которая обычно называется ID. Как ее получить после добавления дело ваше, но в возвращаемом объекте new_row она уже должна быть. Для того, чтобы это все стало немного более понятно, я прикладываю сюда otclass2.pl. Там нет реально работы с базой, зато все эти входы-выходы показаны.

## полезняшки ##

Функция get_row(uslovie) - возвращает первую запись, подходящую под условие 
Функция get_row(uslovie,clone) - возвращает клона первой запись, подходящую под условие 
 
## Demo ##

В демке есть несколько моментов, с которыми можно поиграться. 

* попробуйте заменить в конструкторе значение sort c age на name
* вообще убрать sort из констурктора
* заменить в конструкторе 'tmpl' на 'tmpl2'

## Замещение ##

В данный момент есть 5 функций, которые можно заменять.

* this.__sort - вызывается с параметром field, которые указывает по какому полю или списку полей сортировать
* this.before_render -  тут все ясно по названию
* this.after_render - тут все ясно по названию
* this.before_sync - тут все ясно по названию
* this.after_sync - тут все ясно по названию
* before_action - функция, запускается перед каждый действие. я ее использую для "затемнения" экрана.
* after_action - а эту для снятия "затемнения".

## ToDo ##

- [ ] работа с before и after функциями
- [ ] сделать возможность работать с разными шаблонизаторами
- [x] сортировка по полю с символом минус. Т.е. desc
- [x] сортировка по нескольким полям
- [ ] у remove eq может принимать:
    - [ ] массив
    - [ ] регулярку
- [ ] параметр в add чтобы не работать с базой
    - [ ] надо ли это?
    - [ ] если сделать, то надо переделать конструктор
- [ ] другие условия
  - [ ] больше
  - [ ] меньше
  - [ ] больше или равно
  - [ ] меньше или равно
